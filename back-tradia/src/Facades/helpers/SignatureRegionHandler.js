const sharp = require("sharp");

/**
 * This helper looks for placeholder elements that mark original
 * signature / stamp regions in the page HTML and replaces them
 * with <img> tags that embed a cropped portion of the original
 * page image as a base64 data URL.
 *
 * Expected placeholder format in the HTML, generated by the LLM:
 *   <div
 *     class="maria-signature"
 *     data-x="0.75"
 *     data-y="0.82"
 *     data-width="0.15"
 *     data-height="0.08"
 *     [data-scale="1.1"] (optional, overrides default scaling)
 *   ></div>
 *
 * - x, y, width, height are relative (0-1) to the page dimensions.
 * - x, y represent the top-left corner of the region.
 *
 * - The final rendered img size is:
 *   - cropped from the original page using the exact region;
 *   - scaled in CSS by a configurable factor (default 1.0) so you can
 *     make marks slightly larger or smaller without changing the LLM.
 *
 * @param {string} html - HTML generated by the LLM for a single page
 * @param {object} page - Page metadata from FileManagementService.getImagesFromPath
 * @param {string} page.image.path - Absolute path to the original page image
 * @param {object} page.page_info.dimensions - { width, height } of the page in px
 * @returns {Promise<string>} - HTML with <img> tags instead of placeholders
 */

// Global fallback for how much to scale logos/signatures relative to the
// LLM‑reported region. Can be overridden per placeholder with data-scale.
const DEFAULT_SCALE =
	typeof process !== "undefined" && process.env.MARIA_SIGNATURE_SCALE
		? Number.parseFloat(process.env.MARIA_SIGNATURE_SCALE) || 1
		: 1;
async function injectSignatureImages(html, page) {
	if (!html || !page || !page.image?.path || !page.page_info?.dimensions) {
		return html;
	}

	const { width: pageWidth, height: pageHeight } = page.page_info.dimensions;

	// Match any tag that contains the "maria-signature" class.
	// We keep the whole original match string so we can safely replace it later.
	const placeholderRegex =
		/<([a-zA-Z0-9]+)([^>]*class=["'][^"']*maria-signature[^"']*["'][^>]*)>([\s\S]*?)<\/\1>/gi;

	const placeholders = [];

	let match;
	while ((match = placeholderRegex.exec(html)) !== null) {
		const [fullMatch, , attrs] = match;

		function extractAttr(name) {
			const attrRegex = new RegExp(
				`${name}=["']\\s*([0-9]+(?:\\.[0-9]+)?)\\s*["']`,
				"i",
			);
			const attrMatch = attrs.match(attrRegex);
			if (!attrMatch) return null;
			const value = parseFloat(attrMatch[1]);
			return Number.isFinite(value) ? value : null;
		}

		const relX = extractAttr("data-x");
		const relY = extractAttr("data-y");
		const relW = extractAttr("data-width");
		const relH = extractAttr("data-height");

		if (
			relX === null ||
			relY === null ||
			relW === null ||
			relH === null ||
			pageWidth == null ||
			pageHeight == null
		) {
			continue;
		}

		const scaleAttr = extractAttr("data-scale");
		const scale =
			typeof scaleAttr === "number" && scaleAttr > 0 ? scaleAttr : DEFAULT_SCALE;

		placeholders.push({
			fullMatch,
			coords: { relX, relY, relW, relH, scale },
		});
	}

	if (!placeholders.length) return html;

	const crops = await Promise.all(
		placeholders.map(async ({ fullMatch, coords }) => {
			try {
				const { relX, relY, relW, relH, scale } = coords;

				// Clamp values to [0, 1] and avoid degenerate crops.
				const x = Math.min(Math.max(relX, 0), 1);
				const y = Math.min(Math.max(relY, 0), 1);
				const w = Math.min(Math.max(relW, 0.001), 1);
				const h = Math.min(Math.max(relH, 0.001), 1);

				const left = Math.round(x * pageWidth);
				const top = Math.round(y * pageHeight);
				const cropWidth = Math.round(w * pageWidth);
				const cropHeight = Math.round(h * pageHeight);

				// Ensure crop stays within image bounds.
				const safeLeft = Math.max(0, Math.min(left, pageWidth - 1));
				const safeTop = Math.max(0, Math.min(top, pageHeight - 1));
				const safeWidth = Math.max(
					1,
					Math.min(cropWidth, pageWidth - safeLeft),
				);
				const safeHeight = Math.max(
					1,
					Math.min(cropHeight, pageHeight - safeTop),
				);

				const buffer = await sharp(page.image.path)
					.extract({
						left: safeLeft,
						top: safeTop,
						width: safeWidth,
						height: safeHeight,
					})
					.png()
					.toBuffer();

				const base64 = buffer.toString("base64");
				const dataUrl = `data:image/png;base64,${base64}`;

				// Compute a scaled box around the original region so we can
				// slightly enlarge or shrink marks while keeping them centered.
				const s = Number.isFinite(scale) && scale > 0 ? scale : 1;

				let boxWidth = relW * s;
				let boxHeight = relH * s;
				let boxX = relX - (boxWidth - relW) / 2;
				let boxY = relY - (boxHeight - relH) / 2;

				// Clamp box to [0,1] so it never goes outside the page.
				boxWidth = Math.min(boxWidth, 1);
				boxHeight = Math.min(boxHeight, 1);
				boxX = Math.max(0, Math.min(boxX, 1 - boxWidth));
				boxY = Math.max(0, Math.min(boxY, 1 - boxHeight));

				const leftPercent = boxX * 100;
				const topPercent = boxY * 100;
				const widthPercent = boxWidth * 100;
				const heightPercent = boxHeight * 100;

				// The image is cropped exactly from the original, then scaled
				// to fill the scaled box. This keeps proportions and lets us
				// adapt size via DEFAULT_SCALE or per‑element data-scale.
				const imgTag = `<img class="maria-signature" src="${dataUrl}" style="position:absolute; left:${leftPercent}%; top:${topPercent}%; width:${widthPercent}%; height:${heightPercent}%;"/>`;

				return { fullMatch, replacement: imgTag };
			} catch (error) {
				console.error(
					"[SignatureRegionHandler] Error creating signature crop:",
					error?.message || error,
				);
				return { fullMatch, replacement: fullMatch };
			}
		}),
	);

	let resultHtml = html;
	for (const { fullMatch, replacement } of crops) {
		resultHtml = resultHtml.replace(fullMatch, replacement);
	}

	return resultHtml;
}

module.exports = {
	injectSignatureImages,
};


